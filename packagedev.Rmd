---
title: "Package Development in R"
author: "Asher Spector"
date: "March 2, 2018"
output: html_document
---

To do: 
1. Add in pictures
2. Add in examples of "general" coding comments
3. Add in documentation for s3/s4 classes
4. Update all images
5. Do carlos and I switch places a lot?
6. Suggests section

This page will walk you through the structure, motivation, and process of building packages in R. We'd like to extend a huge thank you to Hadley Wickham's book [R packages](http://r-pkgs.had.co.nz/r.html#r); this part of the guide is basically a condensed and simplified version of that book. A huge portion of the credit should go to him. 

## 1. Motivation

Imagine Grace has built an architecture for aggregating polling data, and you would like to use it in your own research project. So you go to github and you download Grace's repository, hoping to build on her research. One of the scripts you download looks like this. 

![*This is not what packages should look like*](Images/badexample.PNG)

When you read this script, you should notice at least a couple of problems.

First, upon reading this code, most programmers would have absolutely no idea what it's supposed to do. Because this is a simple example, you might be able to guess that the lm function returns the squared difference of its inputs, and the sqt function takes the square root of negative numbers. But the "scalep" function is almost totally incomprehensible - what's it supposed to do? 

Second, even if you could tell what the "scalep" function does, you'd have no idea how to use it, because you don't know how the "datapath.csv" csv file should be structured. 

Third, it's very difficult to use this script in combination with other packages. The "lm" function has the same name as the "lm" function from the R Stats package, which is incredibly useful, and very commonly used. Giving a new function the same name as a base function will create extremely weird bugs or just cause a fatal error and end your entire session. 

Lastly, and less obviously, you don't know what *version* of Grace's package this script is. Grace will probably update and modify her scripts over time, and unless you are aware of the contents of those changes, the script may behave differently than you expect.

Yet never fear - packages don't need to be this way! Most packages are extremely well-built and easy to use. In this section, we'll demonstrate how to make sure your packages are like those packages. 

## 2. Solutions

In this section, we'll discuss the solutions to the problems outlined above. For each problem, we'll discuss the conceptual solution, and then we'll describe how the structure of R Packages allows users to integrate those solutions. Note that this section mostly just outlines package structure - we won't talk about actually creating things like documentation until the next couple sections. 

### 2.1 Code Style

The first solution is to write code differently. The script above has a couple problems with style. Specifically, note the difference between the following two code samples:

```{r}
sqt <- function(x){
  if(x==0){return(x)}
  else if(x>0){return(sqrt(x))}
  else if(x<0){return(complex(real = 0, imaginary = sqrt(-x)))}
}
```


```{r, eval=FALSE}

# This function takes the complex square root of real numbers

general_sqrt <- function (x) {
  
  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(sqrt(x))
  } 
  
  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  } 
  
}

```

Clearly, the second example is a lot more readable and a lot easier to understand. Later, we'll talk about specific coding guidelines, but for now, just remember that the goal of programming style guides is to make your code *readable* and therefore *useable*. This will also make it a lot easier for others to fix and find bugs in your packaged code. 

### 2.2 Documentation

Of course, nobody wants to read through packaged code in order to guess what a function does. Instead, packages also include documentation to tell users how to use different functions and objects developed in the package. For exampe, imagine you typed '?scalep' into the Console and got the following result:

![*Documentation for scalep function*](Images/PackageSS/scalepdoc.PNG)

This documentation tells you what the scalep function does, what kinds of inputs it needs, what kind of output it returns, and gives you examples of how to use it. Documentation makes packages usable, and is suprisingly easy to write using devtools and roxygen2, so it's a critical part of any package. 

### 2.3 Description

The Description file of an R Package helps solve each one of the first three problems. It briefly outlines everything the package does, as well as the version of the pacakge and who maintains it. Perhaps most importantly for newer users, it also documents the dependencies of your package. For example, if you wrote a package which relies heavily on the boot package version 1.3-20, your description will document that, so your users don't have to spend hours searching for the exact package necessary to make your package work. 

### 2.4 Namespace 

The namespace is a bit more complicated than the other parts of the package structure. The purpose of the namespace is make sure your package doesn't conflict with other packages. For example, if your package includes some data labelled 'lm', a good namespace will ensure that using that data in conjunction with the R stats package (which has a function called 'lm') will *not* throw an error. How exactly the namespace does this is a bit complicated and beyond the scope of this guide, so if you're dying for more specifics, you should [read through this wonderful page](http://r-pkgs.had.co.nz/namespace.html). Thankfully, Roxygen2 will automatically generate a namespace for you - we'll discuss how to do this a little later. 

Remember: the namespace will help your package play nice with others in the event of name conflicts, but it's still better to name your functions so that the they don't overlap with names of other commonly used functions if possible. 

Now that we've gone through the overall structure of packages, we'll walk you through what Grace *should* have done - the process of building an R package from start to finish. 

## 3. The Walkthrough

### Step 3.1: Initializing the Package

RStudio makes it easy to create packages. To start, click File>New Project. Then, click "New Directory" when you see the screen below:

![](Images/PackageSS/createproj1.PNG)

Then click "R Package" when you see the screen below:

![](Images/PackageSS/createproj2.PNG)

Lastly, title your package. Your title should be something short and descriptive. Since we'll be walking through a development example, we'll title our new package "devex."

![](Images/PackageSS/createproj3.PNG)

Once you've created your package, your RStudio should look something like this. It should come preloaded with a "Hello World" script which includes a handy function that prints "Hello world."

__ insert blank image of RStudio __

Everything should look mostly the same except for the "Files" tab on the bottom right, which should include an ".Rproj" file, a "DESCRIPTION" file, a "NAMESPACE" file, and a folder titled "R." You should start by checking the little boxes next to the "NAMESPACE" file and the "Hello.R" R script inside the R file and clicking "delete" above them, just because we will have Roxygen2 automatically generate the namespace, and because presumably your package doesn't need a "Hello World" function. Note that your directory section might not include a "man" file just yet - that's because you haven't generated any documentation yet, but that's okay!

You should also go to "Tools > Project Options" and select the following options, which will help you generate documentation and such using roxygen2: 

![](Images/PackageSS/userox.PNG)

### Step 3.2: Modifying the DESCRIPTION File

The DESCRIPTION file gives an extremely brief overview to the package. It includes critical information such as the author of the package, the title, a very short summary of its purpose, and the liscensing information. Double click on the "DESCRIPTION" file on in the files section to open and edit the DESCRIPTION tab. 

DESCRIPTION is a DCF file. This file format may be unfamiliar to you, but it's quite simple. Each line contains a a fieldname and value, separated by a colon. Sometimes, values are long enough to require multiple lines, in which case they are indented by four spaces. For example, the DESCRIPTION file for the devex package might look something like this:

![](Images/PackageSS/description.PNG)

Let's go through the fields and discuss what they mean. The first seven fields listed are mandatory, meaning that if you do not include them, the development environment will throw an error later on when you're trying to build your package. 

1. **Package**: This is the name of the package. It should match the package name you chose earlier, and you should probably just leave this as is. 
2. **Title**: A short but more descriptive title of your package than its name.
3. **Version**: The version of your package. Since you're creating this package for the first time, presumably it's version 0.1.0.
4. **Author**: Here, you should add in your name. 
5. **Maintainer**: Here, you should add in your name as well as a valid email enclosed in <> brackets. Note that if you do not enter a valid email, the development environment may throw errors later. 
6. **Description**: This should be a one-paragraph *comprehensive* description of the package. It is necessarily a high level-description, but it should be a complete one. 
7. **License**: You should add in a License, which describes how others can legally use the package. Most of the time (especially in the US), you should write 'CC0' in the License field, which implies that the package is open for all use, and you have relinquished all your rights to it. For more information on various licensing options, click [this link](https://cran.r-project.org/doc/manuals/r-release/R-exts.html#The-DESCRIPTION-file).
  
(Note all of the fields from this point on are optional, but encouraged!)

8. **Type**: This describes what type of project you're creating - in this case, because you're creating a package, you should write "Package."
9. **Date**: The date, in YYYY-MM-DD fashion. 
10. **LazyData**: Write "true" after LazyData and the colon. Writing 'true' ensures that if you include any data with your package (which you frequently will), when another user loads your package, they won't automatically load up the data, but will only load it if it becomes necessary during their use. This option reduces the amount of RAM users have to expend when loading packages, especially if you are planning to include a lot of data with your package.
11. **Encoding**: Just leave this as "UTF-8"; discussing what encodings are isn't super important for this guide. If you're dying to learn about encodings, visit [this webpage](https://www.w3.org/International/questions/qa-what-is-encoding). 
12. **RoxygenNote**: Roxygen will automatically fill in the version of Roxygen2 used to build the package in this field. 

(These fields are exceptionally important if you are building a package using tools from other packages)

13. **Imports**: In this field, you should list the packages which your package needs to function. Each package should be indented, separated by a comma, and given its own line. For example, a pacakge which requires ggplot2, nlme, and rpart might have an 'imports' field which looks like this:

![](Images/PackageSS/imports.PNG)

14. **Suggests**: Sometimes, your package will run 


### Step 3.3: Starting to Program

#### Step 3.3.1: General Coding Guidelines

All of your code should be in scripts in the 'R' file created in the RStudio package development environment, as shown below:

![](Images/PackageSS/code1.PNG)

The coding you will do in package development is slightly different than the coding you'll normally do when writing R scripts. This is for a couple reasons:

1. When you write a script and load that script using source(script_name), the code in the script runs when you load it (specifically, when you run the 'source' command). On the other hand, the code in a package is run when the package is *built* on your computer. As a result, your code should mostly be focused on building functions, as opposed to a series of actions which the computer ought to take. 
2. Unlike your personal scripts, other people will be using your package, and if your package is good, they'll be using it in ways you didn't anticipate. This means you ought to really try to make sure your code is as general as possible and can support a variety of approaches and implementations. 
3. Also, because other people will be using your package, you should avoid modifying the global RStudio landscape with your package. This means avoiding using functions like require(), library(), or source(); instead, there are other alternatives which can accomplish the same goal without changing the global environment and potentially giving other users an unwanted surprise. For example, instead of using library() and require(), you should be listing your necessary imports in the DESCRIPTION file, as outlinted above. Consider the bad example listed at the beginning of this section, where you saw something that looked like this:

```{r, eval=FALSE}
# Functions for later use

require(ggplot2)

 ...

scalep <- function(d, x=1){
 ...
  qplot(r, geom='histogram')
 ...
}

```

This is a bad example, because it uses "require." Instead, you should be listing your packages' necessary dependencies in the DESCRIPTION file, and then RStudio will make sure anyone who loads your package also loads the other packages you used to write your package (also, when users install your package, RStudio will also make sure that the other packages necessary are installed for other users too). The one catch is that you'll now have to append 'packagename::' in front of the imported functions you want to use, otherwise RStudio won't recognize them. Thus, in the previous example, the code should look something like:

```{r, eval=FALSE}

 ...

scalep <- function(d, x=1){
 ...
  ggplot2::qplot(r, geom='histogram')
 ...
}

```

The last thing you should know is that if you want your package to plot things, you will have to surround the "plot" commands with a print statement, like this:

```{r, eval=FALSE}

 ...

scalep <- function(d, x=1){
 ...
  print(ggplot2::qplot(r, geom='histogram'))
 ...
}


```


You should also take care to organize your functions properly. It's probably a bad idea to stick them all into one script and title it "functions." Instead, you should organize functions by their purposes - for example, a variety of loss functions might go into a single script. Of course, some very complicated functions might deserve their own script. The file names of the script should be descriptive - for example, a script of loss functions might be named "loss_functions.R". 

#### Step 3.3.2: Code Style

Now let's talk about specific elements of code style. These are shortened and adapted from [Hadley Wickham's book on R package development](http://r-pkgs.had.co.nz/r.html), which in turn were adapted from Google's R style guide. For more advice on everything from naming variables to curly bracket placement, head to that aforementioned link.

1. **Comments**: Comments are the best (and easiest) way to make your code readable. In general, you err on the side of commenting too much rather than too little, and your comments should explain the *motivation* of your code as opposed to what your code actually does (although admittedly the line between those two things is a bit blurry). Moreover, you can use lines of '# ---------------------------' or '# ==================' to separate distinct sections of your code. Here's a good, if simple, example of commenting:

```{r}

# This function returns the squared difference element-wise between two vectors

loss <- function(x,y) {

  error <- (x-y)**2

  return(error)
}

#---------------------------------------------------------------------------

# Takes the square root of any real number, returning a complex number

general_sqrt <- function (x) {

  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(complex(real=sqrt(x), imaginary=0))
  }

  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  }

}
```

2. **Names**: Naming variables and functions is tricky - names should be descriptive but concise, and variable names should generally be nouns whereas function names tend to be verbs. Moreover, most R developers keep their function/variable names all lowercase and separate multiple words with underscores. There are no strict rules on this, but at the very least it's nice to be consistent with *some* rules because it makes your code more readable.

```{r, eval = FALSE}
# Bad example - function name
f <- function(x) {
  return(sqrt(x))
}

# Good example - function name
take_sqrt <- function(x){
  return(sqrt(x))
}

# Bad example - variable name
s <- read.table(path)

# Good example - variable name
car_data <- read.table(path)

```

3. **Spacing**: In general, you should use a lot of spaces, because they make your code a lot more readable! Specifically, you should always surround parenthesis with spaces; the exception is when you're making a function call. Note that this means you should surround the parenthesis themselves with spaces, but not the objects within the parenthesis, which should *not* be surrounded with spaces. You should also surround operators (like +, -, <-, =, /, **, others, etc) with spaces; see the examples below.

```{r, eval = FALSE}
# Bad examples of parenthesis spacing

if(a == 7)do(something) # Needs spaces before/after the parenthesis
if ( a == 7 ) # Shouldn't be spaces around 'a == 7'
function_call (parameter) # Shouldn't be a space between function_call and (parameter)

# Good example of parenthesis spacing

if (a == 7) do(something)
function_call(parameter)

# Bad example of operator spacing

a<-a+3 # Needs spaces 

# Good example of operator spacing

a <- a + 3


```

4. **Curly Braces**: You should start a new line after you write an opening curly brace, and ending curly braces should get their own lines, unless you have an else clause. 

```{r, eval = FALSE}
# Bad examples

if (condition) {
  do (x)} # Ending curly brace should get a new line

if (condition) { do(x) }

if (condition) {
  do(x)
}         # The else should be on this line
else {
  do(y)   # Should be indented with two spaces
}


# Good examples

if (condition) {
  do(x)
} else {
  do(y)
}

```

As always, you can break the rules if you have a good reason to. For example, the extra indentation in the following example helps maintain alignment and increases the readability of the code. 

```{r, eval = FALSE}
# Exception which proves the rule - the alignment improves readability
my_function = function(argument_1 = 'this string is extremely long',
                       argument_2 = 'this string is even longer somehow',
                       argument_3 = 'this string is also pretty long') {
  
}
```


Overall, different organizations and programmers have different styles and guidelines for specific coding style. Some programming guides might require you to avoid [camelCase](http://wiki.c2.com/?CamelCase); others might mandate its use. We've tried to document some pretty broadly accepted norms, but in general, you should remember:

1. Your goal should always be to make your code readable!
2. Whatever style guide you follow, following it *consistently* is key to making your code readable
3. You should generally adapt to follow the conventions of the organization you're working under/for

### Step 3.4: Documenting your package

(Note: here, we describe how to document functions. For a more detailed description of how to document S3, S4, and reference classes, check out [this page](http://r-pkgs.had.co.nz/man.html).)

Creating documentation for your package is incredibly easy with Roxygen2. The first thing to do, if you haven't already done it, is to install and load roxygen2 (as documented in the RStudio guidelines page), and then to check the options demonstrated at the end of Step 3.1 in this file.

When you write documentation with roxygen2, the final product should look something like this, which generates the documentation for the "general_sqrt" function above. 

```{r, eval=FALSE}

#' Generalized Square Roots
#'
#' \code{general_sqrt} returns the square root of any real number
#'
#' @param x A real number - integers or doubles are both acceptable.
#' @return A complex value. If x is positive, the imaginary component is equal to 0;
#' if x is negative, the real component is equal to 0.
#'
#' @examples
#' general_sqrt(10)
#' general_sqrt(-10)
#' general_sqrt(-1)
#'
#' @export
# This function takes the complex square root of real numbers

general_sqrt <- function (x) {

  # Return the normal square root if x > 0
  if (x > 0 || x == 0) {
    return(complex(real=sqrt(x), imaginary=0))
  }

  # Else return the complex square root

  else {
    return(complex(real = 0, imaginary = sqrt(-x)))
  }

}
```

![](Images/PackageSS/gensqrtdoc.PNG)

Note that inside the R script, the documentation appears right above the definition of the function - this is helpful because it will help you remember to keep your documentations/functions up to date with each other. Let's work through how this documentation was generated.

1. Note that everything you write in Roxygen2 should be preceded by a #' character combo. This signals to the RStudio environment that you're writing documentation, not code. 

2. You should start your documentation with a very short (2-4 word) title of the function. In the example given above, the "general_sqrt" function is titled "Generalized Square Roots." 

3. You should describe your functions' parameters using the '@param' signifier. This should succintly describe the type (i.e. double, integer, character) of the parameter, as well as its function, as well as any potential default value. 

4. You should document the type of output your function returns. Is it an integer, a dataframe, a matrix? Does it depend on the input? Your documentation should answer these questions!

5. You *must* provide examples of your function's use. These are pretty critical, because a lot of programmers will just skip straight to the examples (and only look at the rest of the documentation if the examples are unclear). 

6. You may choose to write '@export' at the end of your documentation block. You should only do this if you want other people to use the function that you're exporting, because exporting it will make sure it shows up in the namespace. Most functions you write won't be exported - for example, if you write a helper function like 'loss' which is only used in service of a larger function, it shouldn't be exported (exporting too many functions 'clutters' the namespace). Normally, a function as simple as 'general_sqrt' probably wouldn't be exported, but we have exported it for the sake of providing a simple examption. 

Once you've written all your documentation, it's fairly simple to check what it looks like. You should either hit Control+Shift+D, or head to Build>Document in the top pane, which will then automatically generate your documentation. Then, if you've documented a function, you can type ?[function name] into the console, and the documentation should automatically pop up!

(If 'Build' does not show any subobptions and Control+Shift+D is not doing what you expect, it's possible that RStudio does not realize you're supposed to be working inside a package. To get this to happen, in the "Files" tab in the lower right hand corner of RStudio, navigate to your project, and click on the [Project_Name.Rproj] file. Then RStudio should automatically restart and open the project, and you should be able to build or document the package. A picture of what you should click is given below.)

![*Here, you would click devex.Rproj to open the package*](Images/PackageSS/openproj.PNG)

After documenting your package, you can also click the '/man' folder to inspect the documentation html files Roxygen2 generates, but it will probably be less informative than simply typing ?[function name] into the console. 

### Step 3.5 (Optional): Adding and Documenting Data

Sometimes, you'll want to include data as part of your package, either to serve as an example for users or because your functions need it to work. Let's walk through how to include (and document) data in your package. Note that there are at least two kinds of data you should think about including, but for both kinds of data, you should generally save them as '.rdata' or '.rda' files (which are the same thing), because the '.rdata' file format was built for R and has a couple of advantages. 

#### Step 3.5.1: Including data which should be available to users

All of the data you want to be available to users should be saved in a folder called "data" inside your project. The way to do this is to write and run a script which loads your data into R and then uses the devtools function "use_data" to save it to a path inside 'data.' Even if you do not already have a folder called 'data' in your package, the use_data function will make it for you. Note that for this to work, your working directory must be set to the package you're writing, otherwise devtools won't know where to put your data. 

For example, when documenting the scalep function, Carlos might want to include data as an example of a way to use scalep. To this end, he's generated a (totally fake) csv file which lists 100 people's income and luxury spending, and has saved it to the   

```{r, eval=FALSE}
luxspending <- read.csv('C:/Users/Carlos/Documents/R/datapath.csv', header=TRUE, sep=',')
devtools::use_data(luxspending)
```

Data in your 'data' folder will effectively always be exported, so you always must document it. To document data, you should create an R Script in your 'R' directory called ['data.R'] and use Roxygen2 to document the data similarly to the way you'd document a function. For example, Carlos might document the aforementioned data in the following way:

```{r, eval=FALSE}
#' Luxury spending of 100 individuals
#'
#' This dataset lists the net incomes and the luxury spending
#' of 100 individuals.
#'
#' @format A data frame with 100 rows and 2 columns.
#' \describe{
#'   \item{Income}{Total Income, in USD}
#'   \item{Luxury Spending}{Spending on luxury goods, in USD}
#'}
#' @source This dataset was \underline{randomly generated}
#' and is intended only to be used as an example for package
#' development and the scalep function.
"luxspending"
```

This should all look pretty similar to documenting functions. Note that '@format' is a tag which will allow you to describe the structure of a dataset, and it's good practice to list what each column measures in this section. The '@source' section describes where the data came from. Never write '@export' in this section, as data here is already automatically exported.

#### Step 3.5.2: Including data for your functions: 
Some functions may rely on a predefined set of coefficients or other inputs which need to be included in the package. However, users shouldn't generally have access to such data because otherwise they might accidentally radically change the way your function works. It's best to put such data in 'R/sysdata.rda', because then users won't easily be able to access and accidentally modify it. As before, the way to include data in this way is to write a script which loads the data into R and then use the 'use_data' function to save it, but you should also include a parameter 'interior = TRUE' in the function call to let R know that this is interior, not exterior, data. For example, if one of Carlos's functions functions depended on a matrix called "coefficients", he might run the following code:

```{r, eval=FALSE}
coefficients <- read.csv('C:/Users/Carlos/Documents/R/coefs.csv', header=TRUE, sep=',')
devtools::use_data(coefficients, interior = TRUE)
```

Data in 'R/sysdata.rda' is never exported, so there's no need to document it. 

## Step 4: Building Your Package

You're almost done at this point! You've written your functions, modified the description, documented your functions, and presumably exported some of them; you're now ready to *build* your package. Specifically, you should go to Build > 

Sources cited:

http://r-pkgs.had.co.nz/intro.html
